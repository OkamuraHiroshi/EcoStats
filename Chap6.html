<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
 
<body>

## 6 - 1 個体数推定のための調査手法

possum <- read.csv("https://raw.githubusercontent.com/cran/PL.popN/master/data/possum.txt", sep=" ")       # インターネットネット上にあるpossum.txtを取り込む
summary(possum)       # possumの中身を確認

possum$n <- 5-possum$t1     # possumデータから二項分布の試行回数を作成
possum$z <- possum$y-1      # possumデータから二項分布の成功回数を作成
mod0 <- glm(cbind(z,n-z)~1,family=binomial,data=possum)      # 二項分布回帰を実行

logit_p <- mod0$coefficients       # 二項分布回帰で推定された回帰係数
ilogit <- function(x) exp(x)/(1+exp(x))         # logit値を逆変換して確率に戻す関数
( p <- ilogit(logit_p) )       # possumの発見確率

n <- nrow(possum)        # possumのサンプルサイズ
( N <- n/p )        # サンプルサイズを発見確率で割ることで個体数を推定する

library(tidyverse)        # tidyverseパッケージの読み込み
mod1 <- glm(cbind(z,n-z)~x,family=binomial,data=possum)         # 体重量xを説明変数として二項分布回帰する
mod2 <- glm(cbind(z,n-z)~x+I(x^2),family=binomial,data=possum)                 # 体重量xと体重量x^2を説明変数として二項分布回帰する
AIC(mod0, mod1, mod2)          # 説明変数なし，説明変数x，説明変数x + x^2のモデルのAIC比較
new_x <- 30:50         # グラフで予測曲線を描くためのx軸の値
new_possum <- data.frame(x=new_x,y=ilogit(predict(mod2,newdata=list(x=new_x))))
ggplot(new_possum, aes(x,y))+geom_line()+labs(x="Body Weight (g)", y="Detection Probability")+theme_bw()        # AIC最小のモデルmod2による予測結果のプロット

pred_p <- ilogit(predict(mod2))     # mod2を使った場合の発見確率（体重により異なる）
( N_new <- sum(1/pred_p) )        # 体重による発見確率の違いを考慮した個体数推定

numeric_deriv <- function(mod, h=0.00001){     # 個体数推定値のパラメータによる微分を計算する関数
  p <- mod$coef      # 回帰のパラメータ
  X <- model.matrix(mod)        # 説明変数
  d <- h*diag(length(p))        # 数値微分のために回帰係数に足し引きする微小量を与える
  (apply(d, 1, function(x) sum(1/ilogit(X%*%(p+x))))-apply(d, 1, function(x) sum(1/ilogit(X%*%(p-x)))))/(2*h)      # 各パラメータに対する個体数推定値の微分
}
var_N <- t(numeric_deriv(mod2))%*%vcov(mod2)%*%numeric_deriv(mod2)       # デルタ法による個体数の近似分散
se_N <- sqrt(var_N)        # 個体数の標準誤差
( cv_N <- se_N/N_new )       # 個体数の変動係数

alpha <- 1-0.95        # 有意水準の設定
C_ln <- exp(qnorm(1-alpha/2)*sqrt(log(1+cv_N^2)))       # 対数正規分布の近似信頼区間で使用する値
CI_ln <- c(N_new/C_ln, N_new*C_ln)        # 対数正規分布の信頼区間
round(CI_ln, 2)       # 信頼区間を表示

alpha <- 1-0.95       # 有意水準の設定
Sim <- 2000       # シミュレーションの回数
N_b <- NULL       # bootstrap sampleに対する個体数推定値
set.seed(1)       # 乱数発生のseed設定
for (i in 1:Sim){
  id <- sample(n, n, replace=TRUE)        # n個からn個を復元抽出でリサンプル
  mod2b <- glm(cbind(z,n-z)~x+I(x^2),family=binomial,dat=possum[id,])       # bootsrapサンプルデータに対して2次の共変量を持つ二項回帰モデルをフィット
  pred_pb <- ilogit(predict(mod2b))        # 発見確率の推定
  N_b <- c(N_b, sum(1/pred_pb))         # bootstrapによる個体数推定値を保存
}
CI_b <- quantile(N_b,probs=c(alpha/2,1-alpha/2))       # percentile法による信頼区間
round(CI_b, 2)        # 信頼区間の表示

library(Rdistance)          # Rdistanceパッケージの読み込み
data("sparrowDetectionData")         # sparrowDetectionDataの読み込み
dat <- sparrowDetectionData          # sparrowDetectionDataをdatにコピー
dat <- dat %>% mutate(pd=as.numeric(dist))         # pd（垂直横距離を数値化したもの）を新しい変数として追加
p1 <- ggplot(dat, aes(x=pd, y=..density..))+geom_histogram(position="identity",boundary=0,bins=15)+labs(x="Perpendicular Distance (m)")+theme_bw()      # 垂直横距離の確率分布の図
print(p1)       # 図を表示

x_max <- 120       # 横距離の最大値
dat <- dat %>% filter(pd <= 120)       # 横距離を120m以下のものに制限する
p1 <- ggplot(dat, aes(x=pd, y=..density..))+geom_histogram(position="identity",boundary=0, bins=15)+labs(x="Perpendicular Distance (m)")+theme_bw()      # 横距離の確率分布の図
g <- function(x,sigma) exp(-x^2/(2*sigma^2))       # 半正規分布の発見関数
log_like <- function(p, dat, x_max=Inf){        # 発見確率のパラメータ推定のための対数尤度関数
  x <- dat$pd       # 垂直横距離
  x <- x[x <= x_max]        # x_max以下の距離データに制限（truncationと言う）
  sigma <- exp(p)       # 発見確率のパラメータ sigma
#  w <- integrate(g,0,w,sigma=sigma)$value        # 有効探索幅の計算（一般には解析的に求められないので，数値積分などで計算する．発見関数が半正規分布の場合は，pnormで計算可能）
  w <- sqrt(2*pi)*sigma*(pnorm(x_max,0,sigma)-pnorm(0,0,sigma))       # 発見関数が半正規分布のときの有効探索幅
  -sum(log(g(x,sigma))-log(w))       # 横距離データに対する負の対数尤度
}
init_p <- log(mean(dat$pd))      #   発見確率のパラメータ（sigmaの対数値）の初期値（平均横距離の対数を与える）
mod <- nlm(log_like, init_p, dat=dat, x_max=x_max, hessian=TRUE)        # パラメータ推定の最適化
sigma <- exp(mod$estimate)       # 推定結果から発見関数のパラメータsigmaを推定
x <- seq(0,x_max)         # 横距離の範囲
esw <- function(sigma, x_max=Inf) sqrt(2*pi)*sigma*(pnorm(x_max,0,sigma)-pnorm(0,0,sigma))        # 有効探索幅を計算する関数
w <- esw(sigma, x_max)           # 推定パラメータと横距離の最大値から有効探索幅を計算
dat1 <- layer_data(p1)          # 上で作ったggplotのグラフp1から元となるデータを抽出
pred <- sapply(1:nrow(dat1), function(i) sqrt(2*pi)*sigma*(pnorm(dat1$xmax[i],0,sigma)-pnorm(dat1$xmin[i],0,sigma)))         # 垂直横距離の理論的な確率予測値を計算する
pred1 <- pred/sum(pred)*sum(dat1$y)        # グラフで観測度数と予測値の高さを合わせるための調整
p2 <- p1 + geom_line(data=dat1, aes(x=x,y=pred1), color="blue")      # 横距離の元の観測値頻度グラフにモデルから予測された曲線を追加フィットするグラフ
print(p2)        # グラフ描画

data(sparrowSiteData)        # 発見場所に関するライントランセクト調査データ
dat_s <- sparrowSiteData         # sparrowSiteDataをdat_sにコピー
L <- sum(as.numeric(dat_s$length))         # 調査の総距離
n <- nrow(dat)       # 総発見数
A <- 4105*1000^2         # 調査面積（?sparrowSiteDataから情報を得る）
( N <- A*n/(2*L*w) )        # 個体数推定値

numeric_deriv <- function(mod, h=0.00001){       # 有効探索幅のパラメータによる数値微分を行う関数
  p <- mod$estimate      # 最適化で推定されたパラメータ
  d <- h*diag(length(p))         # 数値微分のための微小量の設定
  (apply(d, 1, function(x) esw(exp(p+x)))-apply(d, 1, function(x) esw(exp(p-x))))/(2*h)       # 数値微分
}
var_w <- t(numeric_deriv(mod))%*%(1/mod$hessian)%*%numeric_deriv(mod)       # デルタ法による有効探索幅の分散の計算
cv_w <- sqrt(var_w)/w        # 有効探索幅の変動係数
k <- nrow(dat_s)        # 
n <- tapply(dat$dist, dat$siteID, length)
n[is.na(n)] <- 0
l <- as.numeric(dat_s$length)
mean_nl <- sum(n)/L
var_nl <- 1/(k-1)*sum(l/L*(n/l-mean_nl)^2)
cv_nl <- sqrt(var_nl)/mean_nl
cv_N <- sqrt(cv_nl^2+cv_w^2)
C_ln <- exp(qnorm(1-0.05/2)*sqrt(log(1+cv_N^2)))
CI_ln <- c(N/C_ln, N*C_ln)
round(CI_ln, 2)

## 6 - 2　占有モデル

library(unmarked)
data(crossbill)
dat <- crossbill[, 1:7]
dat$n <- apply(dat[,5:7],1,function(x) sum(!is.na(x)))
dat$x <- apply(dat[,5:7],1,sum,na.rm=TRUE)
dat <- dat[dat$n > 0, ]

</body>
</html>
